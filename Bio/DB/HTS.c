/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2203 from the
 * contents of HTS.xs. Do not edit this file, edit HTS.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "lib/Bio/DB/HTS.xs"
/*
Copyright [2015-2017] EMBL-European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifdef PERL_CAPI
#define WIN32IO_IS_STDIO
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef FCGI
 #include <fcgi_stdio.h>
#else
 #ifdef USE_SFIO
  #include <config.h>
 #else
  #include <stdio.h>
 #endif
 #include <perlio.h>
#endif

#ifndef Newx
#  define Newx(v,n,t) New(0,v,n,t)
#endif

#ifndef Newxz
#  define Newxz(v,n,t) Newz(0,v,n,t)
#endif

#include <unistd.h>
#include <math.h>
#include <string.h>
#include "kseq.h"
#include "hts.h"
#include "sam.h"
#include "khash.h"
#include "faidx.h"
#include "tbx.h"
#include "bgzf.h"
#include "vcf.h"
#include "vcfutils.h"
#include "vcf_sweep.h"
#include "synced_bcf_reader.h"
#include <zlib.h>

/* stolen from bam_aux.c */
#define BAM_MAX_REGION 1<<29

typedef htsFile*        Bio__DB__HTSfile;
typedef bam_hdr_t*      Bio__DB__HTS__Header;
typedef bam1_t*         Bio__DB__HTS__Alignment;
typedef hts_idx_t*      Bio__DB__HTS__Index;
typedef faidx_t*        Bio__DB__HTS__Fai;
typedef bam_pileup1_t*  Bio__DB__HTS__Pileup;
typedef tbx_t*          Bio__DB__HTS__Tabix;
typedef hts_itr_t*      Bio__DB__HTS__Tabix__Iterator;
typedef vcfFile*        Bio__DB__HTS__VCFfile;
typedef bcf_hdr_t*      Bio__DB__HTS__VCF__Header;
typedef bcf1_t*         Bio__DB__HTS__VCF__Row;
KSEQ_INIT(gzFile, gzread)
typedef gzFile          Bio__DB__HTS__Kseq;
typedef kseq_t*         Bio__DB__HTS__Kseq__Iterator;
typedef kstream_t*      Bio__DB__HTS__Kseq__Kstream;
typedef kstring_t*      Bio__DB__HTS__Kseq__Kstring;
typedef bcf_sweep_t*    Bio__DB__HTS__VCF__Sweep;

typedef struct {
  SV* callback;
  SV* data;
} fetch_callback_data;
typedef fetch_callback_data *fetch_callback_dataptr;
typedef struct {
  int    start;
  int    end;
  double width;
  int    reads;
  int*   bin;
} coverage_graph;
typedef coverage_graph *coverage_graph_ptr;

static int MaxPileupCnt=8000;

void XS_pack_charPtrPtr( SV * arg, char ** array, int count) {
  int i;
  AV * avref;
  avref = (AV*)sv_2mortal((SV*)newAV());
  for (i=0; i<count; i++) {
    av_push(avref, newSVpv(array[i], strlen(array[i])));
  }
  SvSetSV( arg, newRV((SV*)avref));
}

int hts_fetch_fun (void *data, bam1_t *b)
{
  dSP;
  int count;

  fetch_callback_dataptr fcp;
  SV* callback;
  SV* callbackdata;
  SV* alignment_obj;
  bam1_t *b2;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam1_t into an appropriate object */
  /* need to dup it here so that the C layer doesn't reuse the address under Perl */
  b2 = bam_dup1(b);

  alignment_obj = sv_setref_pv(newSV(sizeof(bam1_t)),"Bio::DB::HTS::Alignment",(void*) b2);

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(alignment_obj));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;

  return 1;
}

int invoke_pileup_callback_fun(uint32_t tid,
			       uint32_t pos,
			       int n,
			       const bam_pileup1_t *pl,
			       void *data) {
  dSP;
  int count,i;
  fetch_callback_dataptr fcp;
  SV*  callback;
  SV*  callbackdata;
  SV*  pileup_obj;
  SV* p;
  SV** pileups;
  AV*  pileup;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam_pileup1_t into the appropriate object */
  /* this causes a compiler warning -- ignore it */
  pileup = newAV();
  av_extend(pileup,n);
  for (i=0;i<n;i++) {
    p = newSV(sizeof(bam_pileup1_t));
    sv_setref_pv(p,"Bio::DB::HTS::Pileup",(void*) &pl[i]);
    av_push(pileup,p);
  }

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(newSViv(tid)));
  XPUSHs(sv_2mortal(newSViv(pos)));
  XPUSHs(sv_2mortal(newRV_noinc((SV*)pileup)));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;
}

/*
   Declarations to allow add_pileup_line to work
   Ported from samtoosl v1 setup.
*/

/* start pileup support copy from bam.h in samtools */
/* but pileup functions are offered as bam_plp_auto_f in htslib */

typedef int (*bam_pileup_f)(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pl, void *data);

typedef struct
{
  bam_plp_t iter;
  bam_pileup_f func;
  void *data;
} hts_plbuf_t;


hts_plbuf_t *hts_plbuf_init(bam_pileup_f func, void *data)
{
    hts_plbuf_t *buf;
    buf = calloc(1, sizeof(hts_plbuf_t));
    buf->iter = bam_plp_init(0, 0);
    buf->func = func;
    buf->data = data;
    return buf;
}

void hts_plbuf_destroy(hts_plbuf_t *buf)
{
    bam_plp_destroy(buf->iter);
    free(buf);
}

int hts_plbuf_push(const bam1_t *b, hts_plbuf_t *buf)
{
    int ret, n_plp, tid, pos;
    const bam_pileup1_t *plp;
    ret = bam_plp_push(buf->iter, b);
    if (ret < 0) return ret;
    while ((plp = bam_plp_next(buf->iter, &tid, &pos, &n_plp)) != 0)
        buf->func(tid, pos, n_plp, plp, buf->data);
    return 0;
}


/* end pileup support copy from bam.h in samtools */

/**
   pileup support functions
*/
int add_pileup_line (void *data, bam1_t *b)
{
  hts_plbuf_t *pileup = (hts_plbuf_t*) data;
  hts_plbuf_push(b,pileup);
  return 0;
}



int coverage_from_pileup_fun (uint32_t tid,
			      uint32_t pos,
			      int n,
			      const bam_pileup1_t *pl,
			      void *data) {
  coverage_graph_ptr  cgp;
  int                 bin;
  int                 i;
  int                 valid;

  cgp = (coverage_graph_ptr) data;
  cgp->reads += n;

  valid = 0;
  for (i=0;i<n;i++) {
    if (!pl[i].is_del && !pl[i].is_refskip)
        valid++;
  }

  if (pos >= cgp->start && pos <= cgp->end) {
    bin = (pos-cgp->start)/cgp->width;
    cgp->bin[bin] += valid;
  }

  return 0;
}


/**
   From bam_aux.c in samtools. Needed to allow pileup function to work.
*/
int bam_parse_region(bam_hdr_t *header, const char *str, int *ref_id, int *beg, int *end)
{
    const char *name_lim = hts_parse_reg(str, beg, end);
    if (name_lim) {
        char *name = malloc(name_lim - str + 1);
        memcpy(name, str, name_lim - str);
        name[name_lim - str] = '\0';
        *ref_id = bam_name2id(header, name);
        free(name);
    }
    else {
        // not parsable as a region, but possibly a sequence named "foo:a"
        *ref_id = bam_name2id(header, str);
        *beg = 0; *end = INT_MAX;
    }
    if (*ref_id == -1) return -1;
    return *beg <= *end? 0 : -1;
}

/**
   From bam.c in samtools - these are wrappers that can be used OK here.
*/
char *bam_format1(const bam_hdr_t *header, const bam1_t *b)
{
    kstring_t str;
    str.l = str.m = 0; str.s = NULL;
    sam_format1(header, b, &str);
    return str.s;
}


void bam_view1(const bam_hdr_t *header, const bam1_t *b)
{
        char *s = bam_format1(header, b);
        puts(s);
        free(s);
}


/**
   Get the file extension for a filename
*/
int get_index_fmt_from_extension(const char * filename)
{
  char * ext = strrchr( filename, '.' ) ;
  if( strcmp(ext, ".cram")==0 )
  {
    return HTS_FMT_CRAI ;
  }
  if( strcmp(ext, ".bam")==0 )
  {
    return HTS_FMT_BAI ; //could also be HTS_FMT_CSI
  }
  return -1 ;
}

/**
   fetch function
*/
int hts_fetch(htsFile *fp, const hts_idx_t *idx, int tid, int beg, int end, void *data, bam_plp_auto_f func)
{
    int ret;
    hts_itr_t *iter ;
    bam1_t *b ;

    iter = sam_itr_queryi(idx, tid, beg, end);
    b = bam_init1();

    while((ret = sam_itr_next(fp, iter, b)) >= 0)
    {
        func(data,b);
    }
    hts_itr_destroy(iter);
    bam_destroy1(b);
    return (ret == -1)? 0 : ret;
}




#line 372 "lib/Bio/DB/HTS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 424 "lib/Bio/DB/HTS.c"

XS(XS_Bio__DB__HTS__Fai_load); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Fai_load)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"Bio::DB::HTS::Fai\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1));
	Bio__DB__HTS__Fai	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::HTS::Fai";
	else {
	    packname = (char *)SvPV_nolen(ST(0));
	}
#line 370 "lib/Bio/DB/HTS.xs"
    RETVAL = fai_load(filename);
#line 448 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Fai", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Fai_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Fai_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "fai");
    {
	Bio__DB__HTS__Fai	fai;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Fai::destroy",
			"fai", "Bio::DB::HTS::Fai");
#line 379 "lib/Bio/DB/HTS.xs"
    fai_destroy(fai);
#line 479 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Fai_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Fai_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "fai, reg");
    {
	Bio__DB__HTS__Fai	fai;
	const char *	reg = (const char *)SvPV_nolen(ST(1));
#line 387 "lib/Bio/DB/HTS.xs"
    char     *seq;
    int       len;
#line 501 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Fai::fetch",
			"fai", "Bio::DB::HTS::Fai");
#line 390 "lib/Bio/DB/HTS.xs"
    seq = fai_fetch(fai,reg,&len);
    if (seq == NULL)
       XSRETURN_EMPTY;
    RETVAL = newSVpv(seq,len);
    free((void*)seq);
#line 518 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTSfile_max_pileup_cnt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_max_pileup_cnt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "packname, ...");
    {
	int	RETVAL;
	dXSTARG;
#line 404 "lib/Bio/DB/HTS.xs"
	if (items > 1)
	   MaxPileupCnt = SvIV(ST(1));
	RETVAL = MaxPileupCnt;
#line 543 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTSfile_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char *	packname = (char *)SvPV_nolen(ST(0));
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	mode;
	Bio__DB__HTSfile	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2));
	}
#line 418 "lib/Bio/DB/HTS.xs"
        RETVAL = hts_open(filename,mode);
#line 573 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTSfile", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTSfile_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;

	if (sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::close",
			"htsfile", "Bio::DB::HTSfile");
#line 428 "lib/Bio/DB/HTS.xs"
   hts_close(htsfile);
#line 604 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTSfile_index_build); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_index_build)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char *	packname = (char *)SvPV_nolen(ST(0));
	const char *	filename = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;
#line 436 "lib/Bio/DB/HTS.xs"
     RETVAL = sam_index_build(filename,0); //generate BAI for BAM files
#line 627 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTSfile_index_load); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_index_load)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "packname, htsfile");
    {
	char *	packname = (char *)SvPV_nolen(ST(0));
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Index	RETVAL;

	if (sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::index_load",
			"htsfile", "Bio::DB::HTSfile");
#line 446 "lib/Bio/DB/HTS.xs"
      RETVAL = sam_index_load(htsfile, htsfile->fn) ;
#line 659 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Index", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTSfile_index_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_index_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "indexfile");
    {
	Bio__DB__HTS__Index	indexfile;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    indexfile = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::index_close",
			"indexfile", "Bio::DB::HTS::Index");
#line 455 "lib/Bio/DB/HTS.xs"
      hts_idx_destroy(indexfile) ;
#line 690 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTSfile_header_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_header_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;
#line 464 "lib/Bio/DB/HTS.xs"
      bam_hdr_t *bh;
      int64_t result ;
      const htsFormat *format ;
#line 712 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Header	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_read",
			"htsfile", "Bio::DB::HTSfile");
#line 468 "lib/Bio/DB/HTS.xs"
      format = hts_get_format( htsfile ) ;
      if( format->format == bam ) //enum value from htsExactFormat from hts.h
      {
        result = bgzf_seek(htsfile->fp.bgzf,0,0) ;
      }
      bh = sam_hdr_read(htsfile);
      RETVAL = bh ;
#line 731 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Header", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTSfile_header_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_header_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2)
       croak_xs_usage(cv,  "htsfile, header, ...");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
#line 484 "lib/Bio/DB/HTS.xs"
      char *reference = "";
      const htsFormat *format ;
#line 755 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"htsfile", "Bio::DB::HTSfile");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"header", "Bio::DB::HTS::Header");
#line 488 "lib/Bio/DB/HTS.xs"
      format = hts_get_format( htsfile ) ;
      if( format->format == cram )
      {
        if(items > 2)
        {
          reference = (char *)SvPV_nolen(ST(2));
          hts_set_fai_filename(htsfile, reference);
        }
        else
        {
          croak("Error: need reference sequence file for writing CRAM file '%s'", htsfile->fn);
        }
      }
      RETVAL= sam_hdr_write(htsfile,header);
      if (RETVAL != 0)
        croak("Error %d while creating file '%s'", RETVAL, htsfile->fn);
#line 793 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTSfile_read1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_read1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "htsfile, header");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
#line 513 "lib/Bio/DB/HTS.xs"
    bam1_t *alignment;
#line 815 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Alignment	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"htsfile", "Bio::DB::HTSfile");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"header", "Bio::DB::HTS::Header");
#line 515 "lib/Bio/DB/HTS.xs"
       alignment = bam_init1();
       if (sam_read1(htsfile,header,alignment) >= 0) {
         RETVAL = alignment ;
       }
       else
         XSRETURN_EMPTY;
#line 842 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Alignment", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTSfile_write1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTSfile_write1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "htsfile, header, align");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
	Bio__DB__HTS__Alignment	align;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::write1",
			"htsfile", "Bio::DB::HTSfile");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::write1",
			"header", "Bio::DB::HTS::Header");

	if (sv_derived_from(ST(2), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    align = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::write1",
			"align", "Bio::DB::HTS::Alignment");
#line 531 "lib/Bio/DB/HTS.xs"
      RETVAL = sam_write1(htsfile,header,align);
#line 895 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "package=\"Bio::DB::HTS::Alignment\"");
    {
	char *	package;
	Bio__DB__HTS__Alignment	RETVAL;

	if (items < 1)
	    package = "Bio::DB::HTS::Alignment";
	else {
	    package = (char *)SvPV_nolen(ST(0));
	}
#line 542 "lib/Bio/DB/HTS.xs"
      RETVAL = bam_init1();
#line 923 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Alignment", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Alignment::DESTROY",
			"b");
#line 551 "lib/Bio/DB/HTS.xs"
    bam_destroy1(b);
#line 954 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Alignment_tid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_tid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::tid",
			"b", "Bio::DB::HTS::Alignment");
#line 558 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.tid = SvIV(ST(1));
    RETVAL=b->core.tid;
#line 987 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_pos); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_pos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::pos",
			"b", "Bio::DB::HTS::Alignment");
#line 569 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.pos = SvIV(ST(1));
    RETVAL=b->core.pos;
#line 1021 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_calend); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_calend)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::calend",
			"b", "Bio::DB::HTS::Alignment");
#line 580 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_endpos(b);
#line 1053 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_cigar2qlen); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_cigar2qlen)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar2qlen",
			"b", "Bio::DB::HTS::Alignment");
#line 589 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_cigar2qlen(b->core.n_cigar,bam_get_cigar(b));
#line 1085 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_qual); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_qual)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qual",
			"b", "Bio::DB::HTS::Alignment");
#line 598 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.qual = SvIV(ST(1));
    RETVAL=b->core.qual;
#line 1119 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_flag); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_flag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::flag",
			"b", "Bio::DB::HTS::Alignment");
#line 609 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.flag = SvIV(ST(1));
    RETVAL=b->core.flag;
#line 1153 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_n_cigar); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_n_cigar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::n_cigar",
			"b", "Bio::DB::HTS::Alignment");
#line 620 "lib/Bio/DB/HTS.xs"
  if (items > 1)
    b->core.n_cigar = SvIV(ST(1));
    RETVAL=b->core.n_cigar;
#line 1187 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_l_qseq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_l_qseq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_qseq",
			"b", "Bio::DB::HTS::Alignment");
#line 631 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.l_qseq = SvIV(ST(1));
    RETVAL=b->core.l_qseq;
#line 1221 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_qseq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_qseq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 642 "lib/Bio/DB/HTS.xs"
    char* seq;
    int   i;
#line 1243 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qseq",
			"b", "Bio::DB::HTS::Alignment");
#line 645 "lib/Bio/DB/HTS.xs"
    seq = Newxz(seq,b->core.l_qseq+1,char);
    for (i=0;i<b->core.l_qseq;i++) {
      seq[i]=seq_nt16_str[bam_seqi(bam_get_seq(b),i)];
    }
    RETVAL = newSVpv(seq,b->core.l_qseq);
    Safefree(seq);
#line 1261 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment__qscore); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment__qscore)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::_qscore",
			"b", "Bio::DB::HTS::Alignment");
#line 659 "lib/Bio/DB/HTS.xs"
    RETVAL = newSVpv(bam_get_qual(b),b->core.l_qseq);
#line 1293 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_mtid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_mtid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mtid",
			"b", "Bio::DB::HTS::Alignment");
#line 668 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mtid = SvIV(ST(1));
    RETVAL=b->core.mtid;
#line 1328 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_mpos); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_mpos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mpos",
			"b", "Bio::DB::HTS::Alignment");
#line 679 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mpos = SvIV(ST(1));
    RETVAL=b->core.mpos;
#line 1362 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_isize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_isize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::isize",
			"b", "Bio::DB::HTS::Alignment");
#line 690 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.isize = SvIV(ST(1));
    RETVAL=b->core.isize;
#line 1396 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_l_aux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_l_aux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_aux",
			"b", "Bio::DB::HTS::Alignment");
#line 701 "lib/Bio/DB/HTS.xs"
    RETVAL=SvIV(newSViv(bam_get_l_aux(b)));
#line 1428 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_aux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_aux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 709 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type, key[2];
   char    str[8192];
#line 1451 "lib/Bio/DB/HTS.c"
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux",
			"b", "Bio::DB::HTS::Alignment");
#line 713 "lib/Bio/DB/HTS.xs"
   s = bam_get_aux(b);
   str[0] = '\0';

   int left  = sizeof(str) - strlen(str);
   while (left > 0 && (s < b->data + b->l_data)) {
        char* d   = str+strlen(str);

	key[0] = s[0];
	key[1] = s[1];
 	left -= snprintf(d, left, "%c%c:", key[0], key[1]);

	d    += 3;
	s    += 2;
	type = *s++;

	if (left <= 0) continue;

	if (type == 'A')      { left -= snprintf(d, left, "A:%c", *s);           s++; }
	else if (type == 'C') { left -= snprintf(d, left, "i:%u", *s);           s++; }
	else if (type == 'c') { left -= snprintf(d, left, "i:%d", *s);           s++; }
	else if (type == 'S') { left -= snprintf(d, left, "i:%u", *(uint16_t*)s);s += 2; }
	else if (type == 's') { left -= snprintf(d, left, "i:%d", *(int16_t*)s); s += 2; }
	else if (type == 'I') { left -= snprintf(d, left, "i:%u", *(uint32_t*)s);s += 4; }
	else if (type == 'i') { left -= snprintf(d, left, "i:%d", *(int32_t*)s); s += 4; }
	else if (type == 'f') { left -= snprintf(d, left, "f:%g", *(float*)s);   s += 4; }
	else if (type == 'd') { left -= snprintf(d, left, "d:%lg", *(double*)s); s += 8; }
	else if (type == 'Z' || type == 'H') { left -= snprintf(d, left, "%c:", type);
	                                       strncat(d,s,left);
					       while (*s++) {}
					       left = sizeof(str) - strlen(str);
	                                     }
	if (left <= 0) continue;
	strncat(d,"\t",left);
	left--;
   }
   str[strlen(str)-1] = '\0';
   RETVAL = str;
#line 1501 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_aux_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_aux_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "b, tag");
    {
	Bio__DB__HTS__Alignment	b;
	char*	tag = (char *)SvPV_nolen(ST(1));
#line 759 "lib/Bio/DB/HTS.xs"
   int           type;
   uint8_t       *s;
#line 1524 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_get",
			"b", "Bio::DB::HTS::Alignment");
#line 762 "lib/Bio/DB/HTS.xs"
   s    = bam_aux_get(b,tag);
   if (s==0)
      XSRETURN_EMPTY;
   type = *s++;
   switch (type) {
   case 'c':
     RETVAL = newSViv((int32_t)*(int8_t*)s);
     break;
   case 'C':
     RETVAL = newSViv((int32_t)*(uint8_t*)s);
     break;
   case 's':
     RETVAL = newSViv((int32_t)*(int16_t*)s);
     break;
   case 'S':
     RETVAL = newSViv((int32_t)*(uint16_t*)s);
     break;
   case 'i':
     RETVAL = newSViv(*(int32_t*)s);
     break;
   case 'I':
     RETVAL = newSViv((int32_t)*(uint32_t*)s);
     break;
   case 'f':
     RETVAL = newSVnv(*(float*)s);
     break;
   case 'Z':
   case 'H':
     RETVAL = newSVpv((char*)s,0);
     break;
   case 'A':
     RETVAL = newSVpv((char*)s,1);
     break;
   default:
     XSRETURN_EMPTY;
   }
#line 1572 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_aux_keys); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_aux_keys)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Alignment	b;
#line 806 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type;
#line 1597 "lib/Bio/DB/HTS.c"

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_keys",
			"b", "Bio::DB::HTS::Alignment");
#line 809 "lib/Bio/DB/HTS.xs"
   {
     s = bam_get_aux(b);  /* s is a khash macro */
     while (s < b->data + b->l_data) {
       XPUSHs(sv_2mortal(newSVpv(s,2)));
       s   += 2;
       type = *s++;
       if      (type == 'A') { ++s; }
       else if (type == 'C') { ++s; }
       else if (type == 'c') { ++s; }
       else if (type == 'S') { s += 2; }
       else if (type == 's') { s += 2; }
       else if (type == 'I') { s += 4; }
       else if (type == 'i') { s += 4; }
       else if (type == 'f') { s += 4; }
       else if (type == 'Z' || type == 'H') { while (*s) ++(s); ++(s); }
     }
   }
#line 1625 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bio__DB__HTS__Alignment_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
#line 832 "lib/Bio/DB/HTS.xs"
    STRLEN  len;
#line 1646 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data",
			"b", "Bio::DB::HTS::Alignment");
#line 834 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->data     = SvPV(ST(1),len);
      b->l_data = len;
    }
    RETVAL=newSVpv(b->data,b->l_data);
#line 1663 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_data_len); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_data_len)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data_len",
			"b", "Bio::DB::HTS::Alignment");
#line 847 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->l_data = SvIV(ST(1));
    RETVAL=b->l_data;
#line 1698 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_m_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_m_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::m_data",
			"b", "Bio::DB::HTS::Alignment");
#line 858 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->m_data = SvIV(ST(1));
    }
    RETVAL=b->m_data;
#line 1733 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_qname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_qname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qname",
			"b", "Bio::DB::HTS::Alignment");
#line 870 "lib/Bio/DB/HTS.xs"
    RETVAL=newSVpv(bam_get_qname(b),0);
#line 1764 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_paired); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_paired)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::paired",
			"b", "Bio::DB::HTS::Alignment");
#line 879 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPAIRED) != 0;
#line 1797 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_proper_pair); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_proper_pair)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::proper_pair",
			"b", "Bio::DB::HTS::Alignment");
#line 888 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPROPER_PAIR) != 0;
#line 1829 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_unmapped); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_unmapped)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::unmapped",
			"b", "Bio::DB::HTS::Alignment");
#line 897 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FUNMAP) != 0;
#line 1861 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_munmapped); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_munmapped)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::munmapped",
			"b", "Bio::DB::HTS::Alignment");
#line 906 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FMUNMAP) != 0;
#line 1893 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_reversed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_reversed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::reversed",
			"b", "Bio::DB::HTS::Alignment");
#line 915 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_rev(b);
#line 1925 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_mreversed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_mreversed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mreversed",
			"b", "Bio::DB::HTS::Alignment");
#line 924 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_mrev(b);
#line 1957 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Alignment_cigar); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Alignment_cigar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 933 "lib/Bio/DB/HTS.xs"
    int        i;
    uint32_t  *c;
    AV        *avref;
#line 1980 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar",
			"b", "Bio::DB::HTS::Alignment");
#line 937 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    c     = bam_get_cigar(b);
    for (i=0;i<b->core.n_cigar;i++)
      av_push(avref, newSViv(c[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 1997 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Header_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Header_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=Bio::DB::HTS::Header");
    {
	Bio__DB__HTS__Header	RETVAL;
#line 951 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_hdr_init();
#line 2019 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Header", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Header_n_targets); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Header_n_targets)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::n_targets",
			"bamh", "Bio::DB::HTS::Header");
#line 960 "lib/Bio/DB/HTS.xs"
    RETVAL = bamh->n_targets;
#line 2052 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Header_target_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Header_target_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 969 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 2074 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_name",
			"bamh", "Bio::DB::HTS::Header");
#line 972 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
      av_push(avref, newSVpv(bamh->target_name[i],0));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2090 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Header_target_len); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Header_target_len)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 984 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 2113 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_len",
			"bamh", "Bio::DB::HTS::Header");
#line 987 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
       av_push(avref, newSViv(bamh->target_len[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2129 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Header_text); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Header_text)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "bamh, ...");
    {
	Bio__DB__HTS__Header	bamh;
#line 998 "lib/Bio/DB/HTS.xs"
    char   *newtext;
    STRLEN n;
#line 2152 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::text",
			"bamh", "Bio::DB::HTS::Header");
#line 1001 "lib/Bio/DB/HTS.xs"
    /* in case text is not null terminated, we copy it */
    RETVAL = newSVpv(bamh->text,bamh->l_text);
    if (items > 1) {
      newtext = (char*) SvPV(ST(1),n);
      strcpy(bamh->text,newtext);
      bamh->l_text = n;
    }
#line 2171 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Header_parse_region); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Header_parse_region)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "bamh, region");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Header	bamh;
	char*	region = (char *)SvPV_nolen(ST(1));
#line 1018 "lib/Bio/DB/HTS.xs"
       int seqid,start,end;
#line 2196 "lib/Bio/DB/HTS.c"

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::parse_region",
			"bamh", "Bio::DB::HTS::Header");
#line 1020 "lib/Bio/DB/HTS.xs"
    {
      bam_parse_region(bamh,
		       region,
		       &seqid,
		       &start,
		       &end);
      if (seqid < 0)
	XSRETURN_EMPTY;
      else {
	EXTEND(sp,3);
	PUSHs(sv_2mortal(newSViv(seqid)));
	PUSHs(sv_2mortal(newSViv(start)));
	PUSHs(sv_2mortal(newSViv(end)));
      }
    }
#line 2222 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bio__DB__HTS__Header_view1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Header_view1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "bamh, alignment");
    {
	Bio__DB__HTS__Header	bamh;
	Bio__DB__HTS__Alignment	alignment;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"bamh", "Bio::DB::HTS::Header");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    alignment = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"alignment", "Bio::DB::HTS::Alignment");
#line 1042 "lib/Bio/DB/HTS.xs"
       bam_view1(bamh,alignment);
#line 2262 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Header_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Header_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Header::DESTROY",
			"bamh");
#line 1050 "lib/Bio/DB/HTS.xs"
    bam_hdr_destroy(bamh);
#line 2291 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Index_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Index_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	end = (int)SvIV(ST(4));
	CV*	callback;
	SV*	callbackdata;
#line 1066 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
#line 2317 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"bai", "Bio::DB::HTS::Index");

	if (sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"hfp", "Bio::DB::HTSfile");

	if (SvROK(ST(5)) && SvTYPE(SvRV(ST(5)))==SVt_PVCV)
	    callback = (CV*)SvRV(ST(5));
	else
	    Perl_croak(aTHX_ "%s: %s is not a code reference",
			"Bio::DB::HTS::Index::fetch",
			"callback");

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6);
	}
#line 1068 "lib/Bio/DB/HTS.xs"
  {
    fcd.callback = (SV*) callback;
    fcd.data     = callbackdata;
    RETVAL = hts_fetch(hfp,bai,ref,start,end,&fcd,hts_fetch_fun);
  }
#line 2357 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Index_pileup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Index_pileup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	end = (int)SvIV(ST(4));
	CV*	callback;
	SV*	callbackdata;
#line 1087 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
  hts_plbuf_t        *pileup;
#line 2385 "lib/Bio/DB/HTS.c"

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"bai", "Bio::DB::HTS::Index");

	if (sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"hfp", "Bio::DB::HTSfile");

	if (SvROK(ST(5)) && SvTYPE(SvRV(ST(5)))==SVt_PVCV)
	    callback = (CV*)SvRV(ST(5));
	else
	    Perl_croak(aTHX_ "%s: %s is not a code reference",
			"Bio::DB::HTS::Index::pileup",
			"callback");

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6);
	}
#line 1090 "lib/Bio/DB/HTS.xs"
  fcd.callback = (SV*) callback;
  fcd.data     = callbackdata;
  pileup       = hts_plbuf_init(invoke_pileup_callback_fun,(void*)&fcd);
  bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);
  hts_fetch(hfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
  hts_plbuf_push(NULL,pileup);
  hts_plbuf_destroy(pileup);
#line 2425 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Index_coverage); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Index_coverage)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 5 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, bins=0, maxcnt=8000");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	end = (int)SvIV(ST(4));
	int	bins;
	int	maxcnt;
#line 1108 "lib/Bio/DB/HTS.xs"
    coverage_graph  cg;
    hts_plbuf_t    *pileup;
    AV*             array;
    SV*             cov;
    int             i;
    bam_hdr_t      *bh;
    const htsFormat *format ;
#line 2457 "lib/Bio/DB/HTS.c"
	AV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"bai", "Bio::DB::HTS::Index");

	if (sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"hfp", "Bio::DB::HTSfile");

	if (items < 6)
	    bins = 0;
	else {
	    bins = (int)SvIV(ST(5));
	}

	if (items < 7)
	    maxcnt = 8000;
	else {
	    maxcnt = (int)SvIV(ST(6));
	}
#line 1116 "lib/Bio/DB/HTS.xs"
  {
      /* TODO:can we do away with this check by a move to CSI as the standard for BAM indices */
      if (end >= BAM_MAX_REGION)
      {
        format = hts_get_format( hfp ) ;
        if( format->format == bam ) //enum value from htsExactFormat from hts.h
        {
          bgzf_seek(hfp->fp.bgzf,0,0);
          bh = sam_hdr_read(hfp);
          end = bh->target_len[ref];
          bam_hdr_destroy(bh);
        }
      }
      if ((bins==0) || (bins > (end-start)))
         bins = end-start;

      /* coverage graph used to communicate to our callback
	  the region we are sampling */
      cg.start = start;
      cg.end   = end;
      cg.reads = 0;
      cg.width = ((double)(end-start))/bins;
      Newxz(cg.bin,bins+1,int);

      /* accumulate coverage into the coverage graph */
      pileup   = hts_plbuf_init(coverage_from_pileup_fun,(void*)&cg);
      if (items >= 7)
            bam_plp_set_maxcnt(pileup->iter,maxcnt);
      else
            bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);
      hts_fetch(hfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
      hts_plbuf_push(NULL,pileup);
      hts_plbuf_destroy(pileup);

      /* now normalize to coverage/bp and convert into an array */
      array = newAV();
      av_extend(array,bins);
      for  (i=0;i<bins;i++)
           av_store(array,i,newSVnv(((float)cg.bin[i])/cg.width));
      Safefree(cg.bin);
      RETVAL = array;
      sv_2mortal((SV*)RETVAL);  /* this fixes a documented bug in perl typemap */
  }
#line 2533 "lib/Bio/DB/HTS.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Index_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Index_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hts_idx");
    {
	Bio__DB__HTS__Index	hts_idx;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hts_idx = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::close",
			"hts_idx", "Bio::DB::HTS::Index");
#line 1167 "lib/Bio/DB/HTS.xs"
    hts_idx_destroy(hts_idx) ;
#line 2564 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Pileup_qpos); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_qpos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::qpos",
			"pl", "Bio::DB::HTS::Pileup");
#line 1177 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos;
#line 2595 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Pileup_pos); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_pos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::pos",
			"pl", "Bio::DB::HTS::Pileup");
#line 1185 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos+1;
#line 2627 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Pileup_indel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_indel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::indel",
			"pl", "Bio::DB::HTS::Pileup");
#line 1193 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->indel;
#line 2659 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Pileup_level); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_level)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::level",
			"pl", "Bio::DB::HTS::Pileup");
#line 1201 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->level;
#line 2691 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Pileup_is_del); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_is_del)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_del",
			"pl", "Bio::DB::HTS::Pileup");
#line 1209 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_del;
#line 2723 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Pileup_is_refskip); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_is_refskip)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_refskip",
			"pl", "Bio::DB::HTS::Pileup");
#line 1217 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_refskip;
#line 2755 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Pileup_is_head); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_is_head)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_head",
			"pl", "Bio::DB::HTS::Pileup");
#line 1225 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_head;
#line 2787 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Pileup_is_tail); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_is_tail)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_tail",
			"pl", "Bio::DB::HTS::Pileup");
#line 1233 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_tail;
#line 2819 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Pileup_b); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_b)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::b",
			"pl", "Bio::DB::HTS::Pileup");
#line 1241 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2850 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Alignment", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Pileup_alignment); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Pileup_alignment)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::alignment",
			"pl", "Bio::DB::HTS::Pileup");
#line 1249 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2882 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Alignment", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Tabix_tbx_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Tabix_tbx_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "fname");
    {
	char *	fname = (char *)SvPV_nolen(ST(0));
	Bio__DB__HTS__Tabix	RETVAL;
#line 1261 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_index_load(fname);
#line 2905 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Tabix", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Tabix_tbx_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Tabix_tbx_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_close",
			"t", "Bio::DB::HTS::Tabix");
#line 1270 "lib/Bio/DB/HTS.xs"
    tbx_destroy(t);
#line 2936 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Tabix_tbx_query); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Tabix_tbx_query)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "t, region");
    {
	Bio__DB__HTS__Tabix	t;
	char *	region = (char *)SvPV_nolen(ST(1));
	Bio__DB__HTS__Tabix__Iterator	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_query",
			"t", "Bio::DB::HTS::Tabix");
#line 1278 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_itr_querys(t, region);
#line 2967 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Tabix::Iterator", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Tabix_tbx_header); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Tabix_tbx_header)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "fp, tabix");
    {
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	tabix;
#line 1289 "lib/Bio/DB/HTS.xs"
    int num_header_lines = 0;
    AV *av_ref;
    kstring_t str = {0,0,0};
#line 2992 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"fp", "Bio::DB::HTSfile");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    tabix = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"tabix", "Bio::DB::HTS::Tabix");
#line 1293 "lib/Bio/DB/HTS.xs"
    av_ref = newAV();
    while ( hts_getline(fp, KS_SEP_LINE, &str) >= 0 ) {
        if ( ! str.l ) break; //no lines left so we are done
        if ( str.s[0] != tabix->conf.meta_char ) break;

        //the line begins with a # so add it to the array
        ++num_header_lines;
        av_push(av_ref, newSVpv(str.s, str.l));
    }

    if ( ! num_header_lines )
        XSRETURN_EMPTY;

    RETVAL = newRV_noinc((SV*) av_ref);
    free(str.s);
#line 3028 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Tabix_tbx_seqnames); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Tabix_tbx_seqnames)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;
#line 1315 "lib/Bio/DB/HTS.xs"
    const char **names;
    int i, num_seqs;
    AV *av_ref;
#line 3052 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_seqnames",
			"t", "Bio::DB::HTS::Tabix");
#line 1319 "lib/Bio/DB/HTS.xs"
    names = tbx_seqnames(t, &num_seqs); //call actual tabix method

    //blast all the values onto a perl array
    av_ref = newAV();
    for (i = 0; i < num_seqs; ++i) {
        SV *sv_ref = newSVpv(names[i], 0);
        av_push(av_ref, sv_ref);
    }

    free(names);

    //return a reference to our array
    RETVAL = newRV_noinc((SV*)av_ref);
#line 3077 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "iter, fp, t");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	t;
#line 1343 "lib/Bio/DB/HTS.xs"
    kstring_t str = {0,0,0};
#line 3101 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"iter", "Bio::DB::HTS::Tabix::Iterator");

	if (sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"fp", "Bio::DB::HTSfile");

	if (sv_derived_from(ST(2), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"t", "Bio::DB::HTS::Tabix");
#line 1345 "lib/Bio/DB/HTS.xs"
    if (tbx_itr_next(fp, t, iter, &str) < 0) {
        free(str.s);
        XSRETURN_EMPTY;
    }

    RETVAL = newSVpv(str.s, str.l);
    free(str.s);

#line 3139 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "iter");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_free",
			"iter", "Bio::DB::HTS::Tabix::Iterator");
#line 1360 "lib/Bio/DB/HTS.xs"
	tbx_itr_destroy(iter);
#line 3170 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__VCFfile_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCFfile_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char*	packname = (char *)SvPV_nolen(ST(0));
	char*	filename = (char *)SvPV_nolen(ST(1));
	char*	mode;
	Bio__DB__HTS__VCFfile	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2));
	}
#line 1372 "lib/Bio/DB/HTS.xs"
      RETVAL = bcf_open(filename, mode);
#line 3199 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::VCFfile", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCFfile_header_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCFfile_header_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "vfile");
    {
	Bio__DB__HTS__VCFfile	vfile;
#line 1381 "lib/Bio/DB/HTS.xs"
        bcf_hdr_t* h;
#line 3221 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Header	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::header_read",
			"vfile", "Bio::DB::HTS::VCFfile");
#line 1383 "lib/Bio/DB/HTS.xs"
        h = bcf_hdr_read(vfile);
        RETVAL = h;
#line 3235 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::VCF::Header", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCFfile_read1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCFfile_read1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "vfile, header");
    {
	Bio__DB__HTS__VCFfile	vfile;
	Bio__DB__HTS__VCF__Header	header;
#line 1394 "lib/Bio/DB/HTS.xs"
        bcf1_t *rec;
#line 3258 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::read1",
			"vfile", "Bio::DB::HTS::VCFfile");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::read1",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1396 "lib/Bio/DB/HTS.xs"
        rec = bcf_init();
        if ( bcf_read(vfile, header, rec) == 0 )
        {
            bcf_unpack(rec, BCF_UN_ALL) ;
            RETVAL = rec ;
        }
        else
        {
            XSRETURN_EMPTY;
        }
#line 3289 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCFfile_num_variants); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCFfile_num_variants)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char*	packname = (char *)SvPV_nolen(ST(0));
	char*	filename = (char *)SvPV_nolen(ST(1));
#line 1416 "lib/Bio/DB/HTS.xs"
        int n_records = 0;
        vcfFile* vfile;
        bcf_hdr_t* h;
        bcf1_t *rec;
#line 3315 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;
#line 1421 "lib/Bio/DB/HTS.xs"
        vfile = bcf_open(filename, "r");
        h = bcf_hdr_read(vfile);
        rec = bcf_init();

        //loop through all the lines but don't do anything with them
        while(bcf_read(vfile, h, rec) == 0)
        {
            ++n_records;
        }
        bcf_close(vfile) ;
        RETVAL = newSViv(n_records);
#line 3329 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCFfile_vcf_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCFfile_vcf_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "vfile, h");
    {
	Bio__DB__HTS__VCFfile	vfile;
	Bio__DB__HTS__VCF__Header	h;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::vcf_close",
			"vfile", "Bio::DB::HTS::VCFfile");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    h = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::vcf_close",
			"h", "Bio::DB::HTS::VCF::Header");
#line 1442 "lib/Bio/DB/HTS.xs"
        bcf_hdr_destroy(h);
        bcf_close(vfile);
#line 3371 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__VCF__Header_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Header_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1453 "lib/Bio/DB/HTS.xs"
#line 3390 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::version",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1454 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(bcf_hdr_get_version(header),0) ;
#line 3403 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Header_num_samples); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Header_num_samples)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1463 "lib/Bio/DB/HTS.xs"
#line 3424 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::num_samples",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1464 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_hdr_nsamples(header) ;
#line 3438 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Header_get_sample_names); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Header_get_sample_names)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1473 "lib/Bio/DB/HTS.xs"
        int nsamples = 0 ;
        int i ;
        AV *av_ref;
#line 3461 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::get_sample_names",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1477 "lib/Bio/DB/HTS.xs"
        av_ref = newAV();
        nsamples = bcf_hdr_nsamples(header) ;
        for (i=0 ; i<nsamples ; i++)
        {
            SV *sv_ref = newSVpv(header->samples[i], 0);
            av_push(av_ref, sv_ref);
        }
        RETVAL = newRV_noinc((SV*)av_ref);
#line 3481 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Header_num_seqnames); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Header_num_seqnames)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1492 "lib/Bio/DB/HTS.xs"
        int nseq = 0 ;
#line 3503 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::num_seqnames",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1494 "lib/Bio/DB/HTS.xs"
     bcf_hdr_seqnames(header, &nseq);
     RETVAL = nseq;
#line 3518 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Header_get_seqnames); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Header_get_seqnames)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1504 "lib/Bio/DB/HTS.xs"
        int nseq = 0 ;
        const char **seqnames ;
        int i = 0 ;
        AV *av_ref = newAV() ;
#line 3542 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::get_seqnames",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1509 "lib/Bio/DB/HTS.xs"
        seqnames = bcf_hdr_seqnames(header, &nseq);
        for (i = 0; i < nseq; i++)
        {
            SV *sv_ref = newSVpv(seqnames[i], 0);
            av_push(av_ref, sv_ref);
        }
        free(seqnames) ;
        RETVAL = newRV_noinc((SV*)av_ref);
#line 3562 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_print); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_print)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1531 "lib/Bio/DB/HTS.xs"
     int i ;
#line 3585 "lib/Bio/DB/HTS.c"

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::print",
			"row", "Bio::DB::HTS::VCF::Row");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::print",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1533 "lib/Bio/DB/HTS.xs"
     printf("\nVCF data line:\n");
     printf("chromosome:%s\t", bcf_hdr_id2name(header,row->rid));
     printf("position:%d\t", (row->pos+1));
     printf("QUAL:%f\t", row->qual);
     printf("ID:%s\t", row->d.id );
     printf("REF:%s\n", row->d.als);
     printf("Num Alleles:%d\n", row->n_allele-1);
     for( i=1 ; i<row->n_allele ; i++ )
     {
       printf("ALT[%d]=%s\t", i, row->d.allele[i]);
     }
     printf("\nNum Filters:%d\n", row->d.n_flt);

#line 3618 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__VCF__Row_chromosome); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_chromosome)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1556 "lib/Bio/DB/HTS.xs"
#line 3638 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::chromosome",
			"row", "Bio::DB::HTS::VCF::Row");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::chromosome",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1557 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(bcf_hdr_id2name(header,row->rid),0) ;
#line 3660 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_position); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_position)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1566 "lib/Bio/DB/HTS.xs"
#line 3681 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::position",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1567 "lib/Bio/DB/HTS.xs"
     RETVAL = row->pos+1;
#line 3695 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_quality); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_quality)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1575 "lib/Bio/DB/HTS.xs"
#line 3715 "lib/Bio/DB/HTS.c"
	float	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::quality",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1576 "lib/Bio/DB/HTS.xs"
     RETVAL = row->qual;
#line 3729 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_id)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1585 "lib/Bio/DB/HTS.xs"
#line 3749 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::id",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1586 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(row->d.id, 0) ;
#line 3762 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_reference); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_reference)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1594 "lib/Bio/DB/HTS.xs"
#line 3783 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::reference",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1595 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(row->d.als, 0) ;
#line 3796 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_num_alleles); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_num_alleles)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1604 "lib/Bio/DB/HTS.xs"
#line 3817 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::num_alleles",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1605 "lib/Bio/DB/HTS.xs"
     RETVAL = row->n_allele-1 ;
#line 3831 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_get_alleles); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_get_alleles)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1614 "lib/Bio/DB/HTS.xs"
     int i;
     AV *av_ref;
#line 3853 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_alleles",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1617 "lib/Bio/DB/HTS.xs"
     av_ref = newAV();
     for (i = 1; i < row->n_allele; ++i) {
        SV *sv_ref = newSVpv(row->d.allele[i], 0);
        av_push(av_ref, sv_ref);
     }
     RETVAL = newRV_noinc((SV*)av_ref);
#line 3871 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_num_filters); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_num_filters)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1630 "lib/Bio/DB/HTS.xs"
#line 3892 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::num_filters",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1631 "lib/Bio/DB/HTS.xs"
     RETVAL = row->d.n_flt ;
#line 3906 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_has_filter); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_has_filter)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "row, header, filter");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	filter = (char *)SvPV_nolen(ST(2));
#line 1641 "lib/Bio/DB/HTS.xs"
#line 3928 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::has_filter",
			"row", "Bio::DB::HTS::VCF::Row");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::has_filter",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1642 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_has_filter(header,row,filter) ;
#line 3951 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_is_snp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_is_snp)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1651 "lib/Bio/DB/HTS.xs"
#line 3971 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::is_snp",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1652 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_is_snp(row) ;
#line 3985 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_get_variant_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_get_variant_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "row, allele_index");
    {
	Bio__DB__HTS__VCF__Row	row;
	int	allele_index = (int)SvIV(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_variant_type",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1662 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_get_variant_type(row, allele_index);
#line 4018 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_get_info_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_get_info_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2));
#line 1673 "lib/Bio/DB/HTS.xs"
      bcf_info_t* info ;
#line 4041 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info_type",
			"row", "Bio::DB::HTS::VCF::Row");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info_type",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1675 "lib/Bio/DB/HTS.xs"
      info = bcf_get_info(header, row, id);
      if( info == NULL )
      {
        RETVAL = newSVpv("",0);
      }
      else
      {
        switch( info->type )
        {
          case BCF_BT_FLOAT:
               RETVAL = newSVpv("Float",0);
               break ;
          case BCF_BT_NULL:
               RETVAL = newSVpv("Flag",0);
               break ;
          case BCF_BT_CHAR:
               RETVAL = newSVpv("String",0);
               break ;
          default:
               RETVAL = newSVpv("Integer",0);
        }
      }
#line 4084 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_get_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_get_info)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2));
#line 1707 "lib/Bio/DB/HTS.xs"
      bcf_info_t* info ;
      int i=0 ;
      int strlength=0 ;
      int* buf_i;
      float* buf_f;
      char* buf_c;
      AV* av_ref;
      int result;
#line 4115 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info",
			"row", "Bio::DB::HTS::VCF::Row");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1716 "lib/Bio/DB/HTS.xs"
      info = bcf_get_info(header, row, id);
      if( info == NULL )
      {
          // info null, nothing to return
          RETVAL = newSVpv("ID_NOT_FOUND",0);
      }
      else
      {
        av_ref = newAV();
        if( info->type == BCF_BT_NULL )
        {
          buf_i = calloc(1, sizeof(int)) ;
          result = bcf_get_info_flag(header,row,id,&buf_i,&(info->len));
          if( result == 1 )
          {
            av_push(av_ref, newSViv(1));
          }
          else
          {
            av_push(av_ref, newSViv(0));
          }
          free(buf_i);
        }
        else if( info->type == BCF_BT_FLOAT )
        {
          buf_f = calloc(info->len, sizeof(float));
          result = bcf_get_info_float(header, row, id, &buf_f, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSVnv(buf_f[i])) ;
          }
          free(buf_f);
        }
        else if( info->type == BCF_BT_CHAR )
        {
          strlength = info->len+1 ;
          buf_c = calloc(strlength, sizeof(char));
          result = bcf_get_info_string(header,row,id,&buf_c,&strlength) ;
          buf_c[info->len] = '\0' ;
          av_push(av_ref, newSVpv(buf_c,0));
          free(buf_c);
        }
        else if( info->type == BCF_BT_INT32 )
        {
          buf_i = calloc(info->len, sizeof(int));
          result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( info->type == BCF_BT_INT16 )
        {
          buf_i = calloc(info->len, sizeof(int));
          result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( info->type == BCF_BT_INT8 )
        {
          buf_i = calloc(info->len, sizeof(int));
          result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        //return a reference to our array
        RETVAL = newRV_noinc((SV*)av_ref);
      }

#line 4212 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_get_format_type); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_get_format_type)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2));
#line 1804 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
#line 4236 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format_type",
			"row", "Bio::DB::HTS::VCF::Row");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format_type",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1806 "lib/Bio/DB/HTS.xs"
      fmt = bcf_get_fmt(header, row, id);
      if( fmt == NULL )
      {
        RETVAL = newSVpv("",0);
      }
      else
      {
        switch( fmt->type )
        {
          case BCF_BT_FLOAT:
               RETVAL = newSVpv("Float",0);
               break ;
          case BCF_BT_CHAR:
               RETVAL = newSVpv("String",0);
               break ;
          default:
               RETVAL = newSVpv("Integer",0);
        }
      }
#line 4276 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_get_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_get_format)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2));
#line 1835 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
      int i ;
      int* buf_i = NULL ;
      float* buf_f = NULL ;
      char* buf_c = NULL ;
      AV* av_ref;
      int ndst = 0 ;
      int result;
#line 4307 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format",
			"row", "Bio::DB::HTS::VCF::Row");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1844 "lib/Bio/DB/HTS.xs"
      fmt = bcf_get_fmt(header, row, id);
      if( fmt == NULL )
      {
          // info null, nothing to return
          RETVAL = newSVpv("ID_NOT_FOUND",0);
      }
      else
      {
        av_ref = newAV();

        if( fmt->type == BCF_BT_FLOAT )
        {
          result = bcf_get_format_float(header, row, id, &buf_f, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSVnv(buf_f[i])) ;
          }
          free(buf_f);
        }
        else if( fmt->type == BCF_BT_CHAR )
        {
          result = bcf_get_format_char(header,row,id,&buf_c,&ndst) ;
          av_push(av_ref, newSVpv(buf_c, ndst+1));
          free(buf_c);
        }
        else if( fmt->type == BCF_BT_INT32 )
        {
          result = bcf_get_format_int32(header, row, id, &buf_i, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( fmt->type == BCF_BT_INT16 )
        {
          result = bcf_get_format_int32(header, row, id, &buf_i, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( fmt->type == BCF_BT_INT8 )
        {
          result = bcf_get_format_int32(header, row, id, &buf_i, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        //return a reference to our array
        RETVAL = newRV_noinc((SV*)av_ref);
      }

#line 4384 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_get_genotypes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_get_genotypes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1910 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
      int ngt ;
      int* gt_arr = NULL ;
      int ngt_arr = 0;
      AV* av_ref;
      int i=0 ;
#line 4412 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_genotypes",
			"row", "Bio::DB::HTS::VCF::Row");

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_genotypes",
			"header", "Bio::DB::HTS::VCF::Header");
#line 1917 "lib/Bio/DB/HTS.xs"
      av_ref = newAV();
      /* Note the VCF header type treats this as a String but BCF treats as an int */
      ngt = bcf_get_genotypes(header, row, &gt_arr, &ngt_arr);
      for( i=0 ; i<ngt_arr ; i++ )
      {
        av_push(av_ref, newSViv(gt_arr[i])) ;
      }
      free(gt_arr);
      RETVAL = newRV_noinc((SV*)av_ref);
#line 4442 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Row_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Row_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "packname, row");
    {
	char*	packname = (char *)SvPV_nolen(ST(0));
	Bio__DB__HTS__VCF__Row	row;

	if (sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::destroy",
			"row", "Bio::DB::HTS::VCF::Row");
#line 1938 "lib/Bio/DB/HTS.xs"
      bcf_destroy(row);
#line 4474 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__VCF__Sweep_sweep_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Sweep_sweep_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	char*	filename = (char *)SvPV_nolen(ST(0));
#line 1949 "lib/Bio/DB/HTS.xs"
        bcf_sweep_t* sweep;
#line 4494 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Sweep	RETVAL;
#line 1951 "lib/Bio/DB/HTS.xs"
        sweep = bcf_sweep_init(filename);
        RETVAL = sweep;
#line 4499 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::VCF::Sweep", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Sweep_header_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Sweep_header_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 1960 "lib/Bio/DB/HTS.xs"
        bcf_hdr_t* h;
#line 4521 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Header	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::header_read",
			"sweep", "Bio::DB::HTS::VCF::Sweep");
#line 1962 "lib/Bio/DB/HTS.xs"
        h = bcf_sweep_hdr(sweep);
        RETVAL = h;
#line 4535 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::VCF::Header", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Sweep_sweep_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Sweep_sweep_next)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 1971 "lib/Bio/DB/HTS.xs"
        bcf1_t* line;
#line 4557 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_next",
			"sweep", "Bio::DB::HTS::VCF::Sweep");
#line 1973 "lib/Bio/DB/HTS.xs"
        line = bcf_sweep_fwd(sweep);
        if( line )
        {
          RETVAL = line;
        }
        else
        {
          XSRETURN_EMPTY ;
        }
#line 4578 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Sweep_sweep_previous); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Sweep_sweep_previous)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 1989 "lib/Bio/DB/HTS.xs"
        bcf1_t* line;
#line 4600 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_previous",
			"sweep", "Bio::DB::HTS::VCF::Sweep");
#line 1991 "lib/Bio/DB/HTS.xs"
        line = bcf_sweep_bwd(sweep);
        if( line )
        {
          RETVAL = line;
        }
        else
        {
          XSRETURN_EMPTY ;
        }
#line 4621 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__VCF__Sweep_sweep_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__VCF__Sweep_sweep_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_close",
			"sweep", "Bio::DB::HTS::VCF::Sweep");
#line 2007 "lib/Bio/DB/HTS.xs"
        bcf_sweep_destroy(sweep);
#line 4652 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Kseq_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "package, filename, mode=\"r\"");
    {
	char *	package = (char *)SvPV_nolen(ST(0));
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	mode;
	Bio__DB__HTS__Kseq	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2));
	}
#line 2020 "lib/Bio/DB/HTS.xs"
      RETVAL = gzopen(filename, mode);
#line 4681 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Kseq", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq_newfh); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq_newfh)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "pack, fh, mode=\"r\"");
    {
	char *	pack = (char *)SvPV_nolen(ST(0));
	PerlIO*	fh = IoIFP(sv_2io(ST(1)));
	char *	mode;
	Bio__DB__HTS__Kseq	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2));
	}
#line 2031 "lib/Bio/DB/HTS.xs"
      RETVAL = gzdopen(PerlIO_fileno(fh), mode);
#line 4712 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Kseq", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq_iterator); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq_iterator)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "fp");
    {
	Bio__DB__HTS__Kseq	fp;
	Bio__DB__HTS__Kseq__Iterator	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::iterator",
			"fp", "Bio::DB::HTS::Kseq");
#line 2040 "lib/Bio/DB/HTS.xs"
      RETVAL = kseq_init(fp);
#line 4744 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Kseq::Iterator", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "fp");
    {
	Bio__DB__HTS__Kseq	fp;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::DESTROY",
			"fp");
#line 2049 "lib/Bio/DB/HTS.xs"
      gzclose(fp);
#line 4775 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Kseq__Kstream_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Kstream_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "package, fh");
    {
	char *	package = (char *)SvPV_nolen(ST(0));
	Bio__DB__HTS__Kseq	fh;
	Bio__DB__HTS__Kseq__Kstream	RETVAL;

	if (sv_derived_from(ST(1), "Bio::DB::HTS::Kseq")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fh = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::new",
			"fh", "Bio::DB::HTS::Kseq");
#line 2059 "lib/Bio/DB/HTS.xs"
      RETVAL = ks_init(fh);
#line 4806 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Kseq::Kstream", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Kstream_begin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Kstream_begin)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::begin",
			"kstr", "Bio::DB::HTS::Kseq::Kstream");
#line 2068 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->begin;
#line 4839 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Kstream_end); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Kstream_end)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::end",
			"kstr", "Bio::DB::HTS::Kseq::Kstream");
#line 2077 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->end;
#line 4871 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Kstream_is_eof); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Kstream_is_eof)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::is_eof",
			"kstr", "Bio::DB::HTS::Kseq::Kstream");
#line 2086 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->is_eof;
#line 4903 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Kstream_buffer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Kstream_buffer)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::buffer",
			"kstr", "Bio::DB::HTS::Kseq::Kstream");
#line 2095 "lib/Bio/DB/HTS.xs"
      RETVAL = (char *)kstr->buf;
#line 4935 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Kstream_fh); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Kstream_fh)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	Bio__DB__HTS__Kseq	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::fh",
			"kstr", "Bio::DB::HTS::Kseq::Kstream");
#line 2104 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->f;
#line 4966 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Kseq", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Kstream_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Kstream_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::Kstream::DESTROY",
			"kstr");
#line 2113 "lib/Bio/DB/HTS.xs"
      ks_destroy(kstr);
#line 4997 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::next_seq_hash",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2122 "lib/Bio/DB/HTS.xs"
      HV * results;
#line 5027 "lib/Bio/DB/HTS.c"
#line 2124 "lib/Bio/DB/HTS.xs"
      results = (HV *)sv_2mortal((SV *)newHV());
      if (kseq_read(it) >= 0) {
          hv_stores(results, "name", newSVpvn(it->name.s, it->name.l));
          hv_stores(results, "desc", newSVpvn(it->comment.s, it->comment.l));
          hv_stores(results, "seq", newSVpvn(it->seq.s, it->seq.l));
          hv_stores(results, "qual", newSVpvn(it->qual.s, it->qual.l));
          RETVAL = newRV((SV *)results);
      } else {
          XSRETURN_UNDEF;
      }
#line 5039 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::next_seq",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2142 "lib/Bio/DB/HTS.xs"
    HV * results;
    HV * class_stash;
    SV * ref;
#line 5073 "lib/Bio/DB/HTS.c"
#line 2146 "lib/Bio/DB/HTS.xs"
    results = (HV *)sv_2mortal((SV *)newHV());
    class_stash = gv_stashpv("Bio::DB::HTS::Kseq::Record", 0);
    if (kseq_read(it) >= 0) {
        hv_stores(results, "name", newSVpvn(it->name.s, it->name.l));
        hv_stores(results, "desc", newSVpvn(it->comment.s, it->comment.l));
        hv_stores(results, "seq", newSVpvn(it->seq.s, it->seq.l));
        hv_stores(results, "qual", newSVpvn(it->qual.s, it->qual.l));
        ref = newRV((SV *)results);
        sv_bless(ref, class_stash);
        RETVAL = ref;
    } else {
        XSRETURN_UNDEF;
    }
#line 5088 "lib/Bio/DB/HTS.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::read",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2167 "lib/Bio/DB/HTS.xs"
#line 5120 "lib/Bio/DB/HTS.c"
#line 2168 "lib/Bio/DB/HTS.xs"
      RETVAL = kseq_read(it);
#line 5123 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_rewind); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_rewind)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::rewind",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2177 "lib/Bio/DB/HTS.xs"
      /* kseq_rewind() doesn't completely rewind the file,
        just resets markers */
      kseq_rewind(it);
      /* use zlib to do so */
      gzrewind(it->f->f);
#line 5157 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_kstream); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_kstream)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	Bio__DB__HTS__Kseq__Kstream	RETVAL;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::kstream",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2188 "lib/Bio/DB/HTS.xs"
      RETVAL = it->f;
#line 5187 "lib/Bio/DB/HTS.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::HTS::Kseq::Kstream", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::name",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2197 "lib/Bio/DB/HTS.xs"
      RETVAL = it->name.s;
#line 5220 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_comment); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_comment)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::comment",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2206 "lib/Bio/DB/HTS.xs"
      RETVAL = it->comment.s;
#line 5252 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_seq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_seq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::seq",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2215 "lib/Bio/DB/HTS.xs"
      RETVAL = it->seq.s;
#line 5284 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_qual); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_qual)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::qual",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2224 "lib/Bio/DB/HTS.xs"
      RETVAL = it->qual.s;
#line 5316 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_last_char); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_last_char)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::last_char",
			"it", "Bio::DB::HTS::Kseq::Iterator");
#line 2233 "lib/Bio/DB/HTS.xs"
      RETVAL = it->last_char;
#line 5348 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__HTS__Kseq__Iterator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__HTS__Kseq__Iterator_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::Iterator::DESTROY",
			"it");
#line 2242 "lib/Bio/DB/HTS.xs"
      kseq_destroy(it);
#line 5378 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Bio__DB__HTS); /* prototype to pass -Wmissing-prototypes */
XS(boot_Bio__DB__HTS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("Bio::DB::HTS::Fai::load", XS_Bio__DB__HTS__Fai_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::destroy", XS_Bio__DB__HTS__Fai_destroy, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::fetch", XS_Bio__DB__HTS__Fai_fetch, file, "$$$");
        newXS("Bio::DB::HTSfile::max_pileup_cnt", XS_Bio__DB__HTSfile_max_pileup_cnt, file);
        (void)newXSproto_portable("Bio::DB::HTSfile::open", XS_Bio__DB__HTSfile_open, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::close", XS_Bio__DB__HTSfile_close, file, "$");
        newXS("Bio::DB::HTSfile::index_build", XS_Bio__DB__HTSfile_index_build, file);
        (void)newXSproto_portable("Bio::DB::HTSfile::index_load", XS_Bio__DB__HTSfile_index_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::index_close", XS_Bio__DB__HTSfile_index_close, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_read", XS_Bio__DB__HTSfile_header_read, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_write", XS_Bio__DB__HTSfile_header_write, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::read1", XS_Bio__DB__HTSfile_read1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::write1", XS_Bio__DB__HTSfile_write1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::new", XS_Bio__DB__HTS__Alignment_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::DESTROY", XS_Bio__DB__HTS__Alignment_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::tid", XS_Bio__DB__HTS__Alignment_tid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::pos", XS_Bio__DB__HTS__Alignment_pos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::calend", XS_Bio__DB__HTS__Alignment_calend, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar2qlen", XS_Bio__DB__HTS__Alignment_cigar2qlen, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qual", XS_Bio__DB__HTS__Alignment_qual, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::flag", XS_Bio__DB__HTS__Alignment_flag, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::n_cigar", XS_Bio__DB__HTS__Alignment_n_cigar, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_qseq", XS_Bio__DB__HTS__Alignment_l_qseq, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qseq", XS_Bio__DB__HTS__Alignment_qseq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::_qscore", XS_Bio__DB__HTS__Alignment__qscore, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mtid", XS_Bio__DB__HTS__Alignment_mtid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mpos", XS_Bio__DB__HTS__Alignment_mpos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::isize", XS_Bio__DB__HTS__Alignment_isize, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_aux", XS_Bio__DB__HTS__Alignment_l_aux, file, "$;$");
        newXS("Bio::DB::HTS::Alignment::aux", XS_Bio__DB__HTS__Alignment_aux, file);
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_get", XS_Bio__DB__HTS__Alignment_aux_get, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_keys", XS_Bio__DB__HTS__Alignment_aux_keys, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data", XS_Bio__DB__HTS__Alignment_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data_len", XS_Bio__DB__HTS__Alignment_data_len, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::m_data", XS_Bio__DB__HTS__Alignment_m_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qname", XS_Bio__DB__HTS__Alignment_qname, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::paired", XS_Bio__DB__HTS__Alignment_paired, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::proper_pair", XS_Bio__DB__HTS__Alignment_proper_pair, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::unmapped", XS_Bio__DB__HTS__Alignment_unmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::munmapped", XS_Bio__DB__HTS__Alignment_munmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::reversed", XS_Bio__DB__HTS__Alignment_reversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mreversed", XS_Bio__DB__HTS__Alignment_mreversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar", XS_Bio__DB__HTS__Alignment_cigar, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::new", XS_Bio__DB__HTS__Header_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::n_targets", XS_Bio__DB__HTS__Header_n_targets, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_name", XS_Bio__DB__HTS__Header_target_name, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_len", XS_Bio__DB__HTS__Header_target_len, file, "$");
        newXS("Bio::DB::HTS::Header::text", XS_Bio__DB__HTS__Header_text, file);
        (void)newXSproto_portable("Bio::DB::HTS::Header::parse_region", XS_Bio__DB__HTS__Header_parse_region, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::view1", XS_Bio__DB__HTS__Header_view1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::DESTROY", XS_Bio__DB__HTS__Header_DESTROY, file, "$");
        newXS("Bio::DB::HTS::Index::fetch", XS_Bio__DB__HTS__Index_fetch, file);
        newXS("Bio::DB::HTS::Index::pileup", XS_Bio__DB__HTS__Index_pileup, file);
        newXS("Bio::DB::HTS::Index::coverage", XS_Bio__DB__HTS__Index_coverage, file);
        newXS("Bio::DB::HTS::Index::close", XS_Bio__DB__HTS__Index_close, file);
        newXS("Bio::DB::HTS::Pileup::qpos", XS_Bio__DB__HTS__Pileup_qpos, file);
        newXS("Bio::DB::HTS::Pileup::pos", XS_Bio__DB__HTS__Pileup_pos, file);
        newXS("Bio::DB::HTS::Pileup::indel", XS_Bio__DB__HTS__Pileup_indel, file);
        newXS("Bio::DB::HTS::Pileup::level", XS_Bio__DB__HTS__Pileup_level, file);
        newXS("Bio::DB::HTS::Pileup::is_del", XS_Bio__DB__HTS__Pileup_is_del, file);
        newXS("Bio::DB::HTS::Pileup::is_refskip", XS_Bio__DB__HTS__Pileup_is_refskip, file);
        newXS("Bio::DB::HTS::Pileup::is_head", XS_Bio__DB__HTS__Pileup_is_head, file);
        newXS("Bio::DB::HTS::Pileup::is_tail", XS_Bio__DB__HTS__Pileup_is_tail, file);
        newXS("Bio::DB::HTS::Pileup::b", XS_Bio__DB__HTS__Pileup_b, file);
        newXS("Bio::DB::HTS::Pileup::alignment", XS_Bio__DB__HTS__Pileup_alignment, file);
        newXS("Bio::DB::HTS::Tabix::tbx_open", XS_Bio__DB__HTS__Tabix_tbx_open, file);
        newXS("Bio::DB::HTS::Tabix::tbx_close", XS_Bio__DB__HTS__Tabix_tbx_close, file);
        newXS("Bio::DB::HTS::Tabix::tbx_query", XS_Bio__DB__HTS__Tabix_tbx_query, file);
        newXS("Bio::DB::HTS::Tabix::tbx_header", XS_Bio__DB__HTS__Tabix_tbx_header, file);
        newXS("Bio::DB::HTS::Tabix::tbx_seqnames", XS_Bio__DB__HTS__Tabix_tbx_seqnames, file);
        newXS("Bio::DB::HTS::Tabix::Iterator::tbx_iter_next", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next, file);
        newXS("Bio::DB::HTS::Tabix::Iterator::tbx_iter_free", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free, file);
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::open", XS_Bio__DB__HTS__VCFfile_open, file, "$$$");
        newXS("Bio::DB::HTS::VCFfile::header_read", XS_Bio__DB__HTS__VCFfile_header_read, file);
        newXS("Bio::DB::HTS::VCFfile::read1", XS_Bio__DB__HTS__VCFfile_read1, file);
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::num_variants", XS_Bio__DB__HTS__VCFfile_num_variants, file, "$$$");
        newXS("Bio::DB::HTS::VCFfile::vcf_close", XS_Bio__DB__HTS__VCFfile_vcf_close, file);
        newXS("Bio::DB::HTS::VCF::Header::version", XS_Bio__DB__HTS__VCF__Header_version, file);
        newXS("Bio::DB::HTS::VCF::Header::num_samples", XS_Bio__DB__HTS__VCF__Header_num_samples, file);
        newXS("Bio::DB::HTS::VCF::Header::get_sample_names", XS_Bio__DB__HTS__VCF__Header_get_sample_names, file);
        newXS("Bio::DB::HTS::VCF::Header::num_seqnames", XS_Bio__DB__HTS__VCF__Header_num_seqnames, file);
        newXS("Bio::DB::HTS::VCF::Header::get_seqnames", XS_Bio__DB__HTS__VCF__Header_get_seqnames, file);
        newXS("Bio::DB::HTS::VCF::Row::print", XS_Bio__DB__HTS__VCF__Row_print, file);
        newXS("Bio::DB::HTS::VCF::Row::chromosome", XS_Bio__DB__HTS__VCF__Row_chromosome, file);
        newXS("Bio::DB::HTS::VCF::Row::position", XS_Bio__DB__HTS__VCF__Row_position, file);
        newXS("Bio::DB::HTS::VCF::Row::quality", XS_Bio__DB__HTS__VCF__Row_quality, file);
        newXS("Bio::DB::HTS::VCF::Row::id", XS_Bio__DB__HTS__VCF__Row_id, file);
        newXS("Bio::DB::HTS::VCF::Row::reference", XS_Bio__DB__HTS__VCF__Row_reference, file);
        newXS("Bio::DB::HTS::VCF::Row::num_alleles", XS_Bio__DB__HTS__VCF__Row_num_alleles, file);
        newXS("Bio::DB::HTS::VCF::Row::get_alleles", XS_Bio__DB__HTS__VCF__Row_get_alleles, file);
        newXS("Bio::DB::HTS::VCF::Row::num_filters", XS_Bio__DB__HTS__VCF__Row_num_filters, file);
        newXS("Bio::DB::HTS::VCF::Row::has_filter", XS_Bio__DB__HTS__VCF__Row_has_filter, file);
        newXS("Bio::DB::HTS::VCF::Row::is_snp", XS_Bio__DB__HTS__VCF__Row_is_snp, file);
        newXS("Bio::DB::HTS::VCF::Row::get_variant_type", XS_Bio__DB__HTS__VCF__Row_get_variant_type, file);
        newXS("Bio::DB::HTS::VCF::Row::get_info_type", XS_Bio__DB__HTS__VCF__Row_get_info_type, file);
        newXS("Bio::DB::HTS::VCF::Row::get_info", XS_Bio__DB__HTS__VCF__Row_get_info, file);
        newXS("Bio::DB::HTS::VCF::Row::get_format_type", XS_Bio__DB__HTS__VCF__Row_get_format_type, file);
        newXS("Bio::DB::HTS::VCF::Row::get_format", XS_Bio__DB__HTS__VCF__Row_get_format, file);
        newXS("Bio::DB::HTS::VCF::Row::get_genotypes", XS_Bio__DB__HTS__VCF__Row_get_genotypes, file);
        newXS("Bio::DB::HTS::VCF::Row::destroy", XS_Bio__DB__HTS__VCF__Row_destroy, file);
        newXS("Bio::DB::HTS::VCF::Sweep::sweep_open", XS_Bio__DB__HTS__VCF__Sweep_sweep_open, file);
        newXS("Bio::DB::HTS::VCF::Sweep::header_read", XS_Bio__DB__HTS__VCF__Sweep_header_read, file);
        newXS("Bio::DB::HTS::VCF::Sweep::sweep_next", XS_Bio__DB__HTS__VCF__Sweep_sweep_next, file);
        newXS("Bio::DB::HTS::VCF::Sweep::sweep_previous", XS_Bio__DB__HTS__VCF__Sweep_sweep_previous, file);
        newXS("Bio::DB::HTS::VCF::Sweep::sweep_close", XS_Bio__DB__HTS__VCF__Sweep_sweep_close, file);
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::new", XS_Bio__DB__HTS__Kseq_new, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::newfh", XS_Bio__DB__HTS__Kseq_newfh, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::iterator", XS_Bio__DB__HTS__Kseq_iterator, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::DESTROY", XS_Bio__DB__HTS__Kseq_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::new", XS_Bio__DB__HTS__Kseq__Kstream_new, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::begin", XS_Bio__DB__HTS__Kseq__Kstream_begin, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::end", XS_Bio__DB__HTS__Kseq__Kstream_end, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::is_eof", XS_Bio__DB__HTS__Kseq__Kstream_is_eof, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::buffer", XS_Bio__DB__HTS__Kseq__Kstream_buffer, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::fh", XS_Bio__DB__HTS__Kseq__Kstream_fh, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::DESTROY", XS_Bio__DB__HTS__Kseq__Kstream_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::next_seq_hash", XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::next_seq", XS_Bio__DB__HTS__Kseq__Iterator_next_seq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::read", XS_Bio__DB__HTS__Kseq__Iterator_read, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::rewind", XS_Bio__DB__HTS__Kseq__Iterator_rewind, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::kstream", XS_Bio__DB__HTS__Kseq__Iterator_kstream, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::name", XS_Bio__DB__HTS__Kseq__Iterator_name, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::comment", XS_Bio__DB__HTS__Kseq__Iterator_comment, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::seq", XS_Bio__DB__HTS__Kseq__Iterator_seq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::qual", XS_Bio__DB__HTS__Kseq__Iterator_qual, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::last_char", XS_Bio__DB__HTS__Kseq__Iterator_last_char, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::DESTROY", XS_Bio__DB__HTS__Kseq__Iterator_DESTROY, file, "$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

